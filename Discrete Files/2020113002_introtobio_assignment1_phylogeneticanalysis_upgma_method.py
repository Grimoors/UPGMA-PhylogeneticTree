# -*- coding: utf-8 -*-
"""2020113002-IntroToBio-Assignment1-PhylogeneticAnalysis-UPGMA-Method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uIcN_dSL9mXEfzu3d2-sY0qc3SQdIOhE

# Questions:

1.	Construct a phylogenetic relationship for the given nucleotide sequences (Nucleotide.txt). 

  1.	Write a script (q1a) to generate a distance matrix csv file for the sequences present in the data file. Name the distance matrix file as 'Ndistance.txt'.

* For example, 

* seq1 = 'ATGCATGCAA' 

* seq2 = 'ATGCATGCTA' 

* Distance (seq1, seq2) = Mismatches/total length = 1/10 = 0.1 

  2.	Write a script (q1b) that uses 'Ndistance.txt' and generate phylogenetic relationship between the organisms using UPGMA method. 


2.	Construct a phylogenetic relationship for the given protein sequences (Protein.txt).

  1.	Write a script (q2a) to generate a distance matrix csv file for the sequences present in the data file. Name the distance matrix file as 'Pdistance.txt'. Use BLOSUM62 for getting score values. 

  2.	Write a script (q2b) that uses 'Pdistance.txt' and generate phylogenetic relationship between the organisms using UPGMA method.

The Goal for this notebook is 

* ***Q1.*** To do phylogenetic tree analysis of the Nucleotide sequences provided.

* ***Q2.*** To construct a phylogenetic relationship tree diagram for the protien seqeunces provided.

#***THOUGHTS AND NOTES:*** <u>UPGMA ASSIGNMENT</u>

## <u>1. What even is UPGMA?</u>

**UPGMA** - stands for <u>**U**</u>nweighted <u>**P**</u>air- <u>**G**</u>roup <u>**M**</u>ethod with <u>**A**</u>rithmetic mean.

Thats a mouthful after unpacking, so lets make it simpler to grasp - 

* ***Unweighted*** - All pairwise distances contribute equally. <s>(There is an assumption here that needs to be adressed in any further attempts to this problem)</s>
* ***Pair- Group*** - groups are combined in pairs (dichotomies only).
* ***Arithmetic Mean*** - pairwise distances to each group (clade) are mean distances to all members of that group.

### <u>a. *What was the assumption?*</u>

UPGMA is a distance method and therefore needs a distance matrix. UPGMA is "ultrametric", meaning that all the terminal nodes (i.e. the sequences/taxa) are **equally distanced from the root**. In molecular terms, this means that UPGMA assumes a **molecular clock**, i.e. all lineages are evolving at a **constant rate**. In practical terms, this means that you can construct a **distance scale bar** and all the terminal nodes will be **level at position 0**.

0, representing the present.

## <u>2. How to do upgma ?</u>

Each round of UPGMA follows the same pattern. 
1. Identify the shortest pairwise distance in the matrix. This identifies the two sequences to be clustered.
2. Join the two sequences identified. 
3. The pair should be linked at a depth that is half of the shortest pairwise distance.
4. The tip-to-tip distance between the joined elements will equal the shortest distance.

## <u>3. Why UPGMA?</u>

UPGMA is a method to tackle the problem of finding out which organism is most related to which one, given we have the genetic sequences of <u>**all**</u> said organisms. 

<u>**TLDR:**</u> Get genetic sequences as <u>*input*</u>, send Phylogenetic tree as <u>*Output*</u>. 

Great. now we have a rough idea of what exactly the beast we are tackling is. At least I do. I have referred to an example provided at http://www.nmsr.org/upgma.htm to help write this program better.

# 4. Break it down - Divide and Conquer
THIS IS A COMPLEX PROBLEM WITH LOTS OF MOVING PARTS.

So Lets think of some simple steps to tackle this problem in.

1. Get genetic sequences as input ( Needs to be tackled seperately for q1 and q2.)
2. Align These sequences, and find the distance between each pair. (We haven't *exactly* been taught this, but we have been given a link to an online tool to do this) <s>(This problem is known to be **<i>N-P</i> HARD**) </s> I used biopython for this.
3. Create a distance matrix out of these. ( should be easy enough, and simple to do for Q1 and Q2 ) easily done using csv
4. Do the UPGMA algo on this.
    
  * this is gonna be involved, but should be same for both Q1 and Q2. 
  * yup this was involved, had to read a lot of blogs to do this. This newick form one was another pain to to. ho gaya bas ... 
5. Note the outputs and Construct a phylogenetic tree from these, and output in a given format.
  * this is gonna be involved, but should be same for both Q1 and Q2. 
  * Used Newick form, sabse aasan tha, I swear 100% copy maara hai.
  *  skipping the visualisation of newick as a visual tree, there are visualisers that take newick form and show a tree, please use one , I am not doing this, it is a data visualisation technique (newick to visual tree) that is not relevant to the UPGMA method. ( already exists online )

We need 4 Script files, q1a.py, q1b.py, q2a.py, q2b.py.
"""

#Ensuring Dependencies : Run first when starting files check

pip install biopython

#Create Nucleotide.txt and Ndistance.txt to run q1a.py and q1b.py



#Copy paste whatever nucleotide.txt should contain, use FASTA format.
#Instead of running this code block you may also upload the file into the $PWD of google colab.

nucleotideTextInput='''>NM_205222.3 Gallus gallus insulin (INS), mRNA
ATATAAATATGGGAAAGAGAATGGGGAAATTTCTACCAGTCTTCATCTCTGAGAGCAAACTTCTCTGCAT
CTCTTTCTCTCTTCTCTGGGCCTCCCCCAGCTCATCATGGCTCTCTGGATCCGATCACTGCCTCTTCTGG
CTCTCCTTGTCTTTTCTGGCCCTGGAACCAGCTATGCAGCTGCCAACCAGCACCTCTGTGGCTCCCACTT
GGTGGAGGCTCTCTACCTGGTGTGTGGAGAGCGTGGCTTCTTCTACTCCCCCAAAGCCCGACGGGATGTC
GAGCAGCCCCTAGTGAGCAGTCCCTTGCGTGGCGAGGCAGGAGTGCTGCCTTTCCAGCAGGAGGAATACG
AGAAAGTCAAGCGAGGGATTGTTGAGCAATGCTGCCATAACACGTGTTCCCTCTACCAACTGGAGAACTA
CTGCAACTAGCCAAGAAGCCGGAAGCGGGCACAGACATACACTTACTCTATCGCACCTTCAAAGCATTTG
AATAAACCTTGTTGGTCTACTGGAAGACTTGTGCC

>NM_001130093.2 Canis lupus familiaris insulin (INS), mRNA
CACCCCGACACGGCCGGCAAACAGGTCGCCATGGCCCTCTGGATGCGCCTCCTGCCCCTGCTGGCCCTGC
TGGCCCTCTGGGCGCCCGCGCCCACCCGAGCCTTCGTTAACCAGCACCTGTGTGGCTCCCACCTGGTAGA
GGCTCTGTACCTGGTGTGCGGGGAGCGCGGCTTCTTCTACACGCCTAAGGCCCGCCGGGAGGTGGAGGAC
CTGCAGGTGAGGGACGTGGAGCTGGCCGGGGCGCCTGGCGAGGGCGGCCTGCAGCCCCTGGCCCTGGAGG
GGGCCCTGCAGAAGCGAGGCATCGTGGAGCAGTGCTGCACCAGCATCTGCTCCCTCTACCAGCTGGAGAA
TTACTGCAACTAGGGGCGCGGGGGGCAGGACGTGGCAGCACCTGCTGCAGGTCACGGTGGCCGCAAGCCT
TCGGCTCTCTGCACCCCAAGTGATTCAATAAACCCTCTGAATG

>KX951416.1 Labeo rohita insulin mRNA, complete cds
CCGATGTGCTCTGAAAGCCTGGATGCAAAAACACCTTCTCTTGTCTACCATCTCTACCATTCCTTGTCCT
CTGCTGCAAGAACAGTGTGACCATGGCAGTGTGGCTCCAGGCTGGTGCTCTTTTGTTCTTGTTGGCCGTC
TCCAGTGTGAACGCTAACGCAGGGGCCCCACAGCATCTGTGTGGATCTCATCTGGTCGATGCCCTCTACC
TGGTCTGTGGTCCAACAGGATTCTTCTACAACCCCAAGAGAGATGTTGACCCTCTTATGGGTTTCCTTCC
TCCAAAATCTGCCCAGGAAACTGAGGTGGCTGACTTTGCATTTAAAGATCATGCCGAGGTGATAAGGAAG
AGAGGCATTGTGGAGCAGTGTTGCCACAAACCCTGCAGTATCTTTGAGCTGCAGAACTACTGTAACTAAA
GAACCTGCACATGTCTTGTGACAACTGCCAGTGACTTTACCACCTGTTTGCACACAGGTATCATGGGAAT
TACGAGAACTAAACAAAAAGTATCTTTTATTTTAAAATAGTTTACTTTT

>BT006808.1 Homo sapiens insulin mRNA, complete cds
ATGGCCCTGTGGATGCGCCTCCTGCCCCTGCTGGCGCTGCTGGCCCTCTGGGGACCTGACCCAGCCGCAG
CCTTTGTGAACCAACACCTGTGCGGCTCACACCTGGTGGAAGCTCTCTACCTAGTGTGCGGGGAACGAGG
CTTCTTCTACACACCCAAGACCCGCCGGGAGGCAGAGGACCTGCAGGTGGGGCAGGTGGAGCTGGGCGGG
GGCCCTGGTGCAGGCAGCCTGCAGCCCTTGGCCCTGGAGGGGTCCCTGCAGAAGCGTGGCATTGTGGAAC
AATGCTGTACCAGCATCTGCTCCCTCTACCAGCTGGAGAACTACTGCAACTAG

>NM_019129.3 Rattus norvegicus insulin 1 (Ins1), mRNA
AACCCTAAGTGACCAGCTACAATCATAGACCATCAGCAAGCAGGTCATTGTTCCAACATGGCCCTGTGGA
TGCGCTTCCTGCCCCTGCTGGCCCTGCTCGTCCTCTGGGAGCCCAAGCCTGCCCAGGCTTTTGTCAAACA
GCACCTTTGTGGTCCTCACCTGGTGGAGGCTCTGTACCTGGTGTGTGGGGAACGTGGTTTCTTCTACACA
CCCAAGTCCCGTCGTGAAGTGGAGGACCCGCAAGTGCCACAACTGGAGCTGGGTGGAGGCCCGGAGGCCG
GGGATCTTCAGACCTTGGCACTGGAGGTTGCCCGGCAGAAGCGTGGCATTGTGGATCAGTGCTGCACCAG
CATCTGCTCCCTCTACCAACTGGAGAACTACTGCAACTGAGTCCACCACTCCCCGCCCACCCCTCTGCAA
TGAATAAAGCCTTTGAATGAGCACCAAAAAAAAAAAAAAAAAA

>NM_001109772.1 Sus scrofa insulin (INS), mRNA
AGCCCTCTGGGACCAGCTGTGTTCCCAGGCCACCGGCAAGCAGGTCCTCACCCCCCGCCATGGCCCTGTG
GACGCGCCTCCTGCCCCTGCTGGCCCTGCTGGCCCTCTGGGCGCCCGCCCCGGCCCAGGCCTTCGTGAAC
CAGCACCTGTGCGGCTCCCACCTGGTGGAGGCGCTGTACCTGGTGTGCGGGGAGCGCGGCTTCTTCTACA
CGCCCAAGGCCCGTCGGGAGGCGGAGAACCCTCAGGCAGGTGCCGTGGAGCTGGGCGGAGGCCTGGGCGG
CCTGCAGGCCCTGGCGCTGGAGGGGCCCCCGCAGAAGCGTGGCATCGTGGAGCAGTGCTGCACCAGCATC
TGTTCCCTCTACCAGCTGGAGAACTACTGCAACTAGGCCGCCCCTGAGGGCGCCTGCTGCTCCCCGCACC
CCAAAACCCAATAAA

>NM_173926.2 Bos taurus insulin (INS), transcript variant 1, mRNA
AGCCCCCCGCCCTCAGGACCGGCTGCATTCGAGGCTGCCAGCAAGCAGGTCCTCGCAGCCCCGCCATGGC
CCTGTGGACACGCCTGGCGCCCCTGCTGGCCCTGCTGGCGCTCTGGGCCCCCGCCCCGGCCCGCGCCTTC
GTCAACCAGCATCTGTGTGGCTCCCACCTGGTGGAGGCGCTGTACCTGGTGTGCGGAGAGCGCGGCTTCT
TCTACACGCCCAAGGCCCGCCGGGAGGTGGAGGGCCCCCAGGTGGGGGCGCTGGAGCTGGCCGGAGGCCC
GGGCGCGGGCGGCCTGGAGGGGCCCCCGCAGAAGCGTGGCATCGTGGAGCAGTGCTGTGCCAGCGTCTGC
TCGCTCTACCAGCTGGAGAACTACTGTAACTAGGCCTGCCCCCGACACCAATAAACCCCTTGACGAGCCC
TGCAAAAAAAAAAA

>NM_001008996.2 Pan troglodytes insulin (INS), mRNA
AGCCCTCCAGGACAGGCTGCATCAGAAGAGGCCATCAAGCAGATCACTGTCCTTCTGCCATGGCCCTGTG
GATGCGCCTCCTGCCCCTGCTGGTGCTGCTGGCCCTCTGGGGACCTGACCCAGCCTCGGCCTTTGTGAAC
CAACACCTGTGCGGCTCCCACCTGGTGGAAGCTCTCTACCTAGTGTGCGGGGAACGAGGCTTCTTCTACA
CACCCAAGACCCGCCGGGAGGCAGAGGACCTGCAGGTGGGGCAGGTGGAGCTGGGCGGGGGCCCTGGTGC
AGGCAGCCTGCAGCCCTTGGCCCTGGAGGGGTCCCTGCAGAAGCGTGGTATCGTGGAACAATGCTGTACC
AGCATCTGCTCCCTCTACCAGCTGGAGAACTACTGCAACTAGATGGAATAAAGCCCTTGAACCAGC

>M57671.1 Octodon degus insulin mRNA, complete cds
GCATTCTGAGGCATTCTCTAACAGGTTCTCGACCCTCCGCCATGGCCCCGTGGATGCATCTCCTCACCGT
GCTGGCCCTGCTGGCCCTCTGGGGACCCAACTCTGTTCAGGCCTATTCCAGCCAGCACCTGTGCGGCTCC
AACCTAGTGGAGGCACTGTACATGACATGTGGACGGAGTGGCTTCTATAGACCCCACGACCGCCGAGAGC
TGGAGGACCTCCAGGTGGAGCAGGCAGAACTGGGTCTGGAGGCAGGCGGCCTGCAGCCTTCGGCCCTGGA
GATGATTCTGCAGAAGCGCGGCATTGTGGATCAGTGCTGTAATAACATTTGCACATTTAACCAGCTGCAG
AACTACTGCAATGTCCCTTAGACACCTGCCTTGGGCCTGGCCTGCTGCTCTGCCCTGGCAACCAATAAAC
CCCTTGAATGAG

>U03610.1 Oryctolagus cuniculus New Zealand White insulin mRNA, complete cds
TCATCGGCTCTGCACCATGGCCTCCCTGGCCGCGCTCCTGCCCCTGCTGGCCCTGCTGGTCCTCTGCAGA
CTGGATCCTGCCCAGGCCTTCGTCAACCAGCACCTGTGCGGCTCTCACCTGGTGGAGGCGCTGTACCTGG
TGTGCGGGGAGCGCGGCTTTTTTTATACACCCAAGTCCCGCCGCGAGGTGGAGGAGCTGCAGGTGGGGCA
GGCGGAGCTGGGCGGGGGGCCCGGCGCGGGCGGCCTGCAGCCCTCGGCGCTGGAGCTGGCCCTGCAGAAG
CGCGGCATCGTGGAGCAGTGTTGCACCAGCATCTGCTCGCTCTACCAGCTGGAGAACTACTGCAACTAGG
GGTGCCCCCCACCCACCCCTGCCCGCGCCCCCCACGCCCCCCGCCCTCGCCCCCACCCAATAAACCCCTC
CACGCGCCCCGGG


'''

with open("Nucleotide.txt", 'x') as f_out:
  f_out.write( nucleotideTextInput )

with open("Ndistance.txt",'x') as f_out:
  f_out.write('')

exit(0)

#q1a.py

'''
 After reading given input of Nucleotide.txt, I see that each new entry begins with a '>',
 followed by a line of Information on the gene, followed by some N lines of ATGC

 Identified as the FASTA format.

 I shall try to use biopython to give us the (n^2 - n)/2 values for distance matrix.

 Resources referred to 
 
 1. https://python.omics.wiki/biopython/examples/read-fasta
 2. https://www.geeksforgeeks.org/biopython-pairwise-alignment/
 3. https://stackoverflow.com/questions/20580657/how-to-read-a-fasta-file-in-python 
 4. https://vlab.amrita.edu/index.php?sub=3&brch=274&sim=1438&cnt=1 
 5. https://www.ebi.ac.uk/seqdb/confluence/display/JDSAT/Clustal+Omega+Help+and+Documentation#ClustalOmegaHelpandDocumentation-sequence 
 6. https://www.tutorialspoint.com/biopython/biopython_sequence_alignments.htm 
 7. https://www.geeksforgeeks.org/biopython-sequence-alignment/#:~:text=Biopython%20%E2%80%93%20Sequence%20Alignment%20Last%20Updated%20%3A%2011,identify%20the%20region%20of%20similarity%20among%20them.%20 
 8. https://www.ncbi.nlm.nih.gov/sra/docs/submitformats/#:~:text=fasta%20files%20may%20be%20submitted%20with%20corresponding%20qual%20files%2C%20too.%20these%20are%20recognized%20in%20the%20sra%20data%20processing%20pipeline%20as%20equivalent%20to%20fastq%20and%20should%20be%20specified%20as%20fastq%20when%20submitting%20the%20data%20files. 
 9. https://www.csestack.org/python-check-if-file-directory-exists/
 10. https://flexiple.com/python-create-file/ 
 11. https://www.askpython.com/python/built-in-methods/python-print-to-file#:~:text=Python%20%E2%80%93%20Print%20to%20File%201%20Method%201%3A,4%20Method%204%3A%20Use%20the%20logging%20module.%20 
 12. https://stackoverflow.com/questions/9426045/difference-between-exit0-and-exit1-in-python#:~:text=exit%20%281%29%20means%20there%20was%20some%20issue%20%2F,A%20zero%20error%20code%20means%20a%20successful%20exit. 


'''

import csv
import os
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
from Bio import pairwise2

def merge(list1, list2):
      
    merged_list = [(list1[i], list2[i]) for i in range(0, len(list1))]
    return merged_list

# Python program to get transpose
# elements of two dimension list
def transpose(l1, l2):
 
    # iterate over list l1 to the length of an item
    for i in range(len(l1[0])):
        # print(i)
        row =[]
        for item in l1:
            # appending to new list with values and index positions
            # i contains index position and item contains values
            row.append(item[i])
        l2.append(row)
    return l2

def main ():
#to help resolve indent errors 
    file_in ='./Nucleotide.txt'
    file_out='./Ndistance.txt'

    if os.access(file_in, os.R_OK):
        print ("File ", file_in ," is accessible to read")
    else:
        print ("File ", file_in ," is not accessible to read, exiting.")
        exit (1)
    
    if os.access(file_out, os.W_OK):
        print ("File ", file_out," is accessible to write \n")
    else:
        print ("File ", file_out," is not accessible to write, exiting.")
        exit (1)

    IdList = list ()
    NucleotideSeqList= list ()

    with open(file_out, 'w') as f_out:
    #to help resolve indent errors   
        print("Beginning to Read ",file_in,"\n")
        for seq_record in SeqIO.parse(open(file_in, mode='r'), 'fasta'):
        #to help resolve indent errors 

            # remove .id from .description record (remove all before first space)
            seq_record.description=' '.join(seq_record.description.split()[1:])
            
            # do something (print or edit seq_record)       
            print('SequenceID = '  + seq_record.id)
            print('Description = ' + seq_record.description)
            print('Sequence = ' + seq_record.seq + '\n' )

            # Save the Sequence into NucleotideSeqList and Id into IdList
            NucleotideSeqList.append( seq_record.seq )
            IdList.append( seq_record.id )

        no_of_nucleotides = len(NucleotideSeqList )
        print(no_of_nucleotides,'Nucleotides scanned into our List\n')
        print("Our Lists are : ",merge ( IdList, NucleotideSeqList ))
        print(NucleotideSeqList)
        print(IdList,"\n")

        #Initialize distance matrix
        dist_Matrix=list()

        #Now to find distances, pairwise 
        for i in range(0,no_of_nucleotides,1):
            column= list ()
            for i_1 in range(0,i+1,1):
                column.append(0)
            for j in range (i+1, no_of_nucleotides, 1):
                #compare with j'th nucleotide, and find best pairing.
                alignments = pairwise2.align.globalxx(NucleotideSeqList[i], NucleotideSeqList[j])
                length = ( max(len(NucleotideSeqList[i]), len(NucleotideSeqList[j])) // 1)
                score= 0
                for alignment in alignments: 
                    # print( (alignment[2]//1) , (alignment[4]//1) , ( (alignment[2]//1)/ (alignment[4]//1) ) ) 
                    if ( (alignment[2]//1) >  score ):
                        score = (alignment[2]//1)
                norm_score = score/length
                print(score,length,norm_score)
                #add to 'column' IMPORTANT LINE - CHANGE THE "score" to "norm_score" to get normalized ans.
                column.append(norm_score)
            dist_Matrix.append(column)
        out_Matrix=list ()
        out_Matrix = transpose (dist_Matrix, out_Matrix)
        print(out_Matrix)
        writer = csv.writer(f_out)
        # f_out.write(str (no_of_nucleotides)+",\n")
        writer.writerows(out_Matrix)
    file_out_2="./Ntaxa.txt"
    with open(file_out_2, 'w') as f_out_2:
      writer = csv.writer(f_out_2)
      writer.writerow (IdList)

if __name__ == "__main__":
    main()

#q1b.py - attempt 1
import csv
import os
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
from Bio import pairwise2

def merge(list1, list2):
      
    merged_list = [(list1[i], list2[i]) for i in range(0, len(list1))]
    return merged_list

# Python program to get transpose
# elements of two dimension list
def transpose(l1, l2):
 
    # iterate over list l1 to the length of an item
    for i in range(len(l1[0])):
        # print(i)
        row =[]
        for item in l1:
            # appending to new list with values and index positions
            # i contains index position and item contains values
            row.append(item[i])
        l2.append(row)
    return l2

def main ():
#to help resolve indent errors 
    file_in ='./Ndistance.txt'
    file_out=''

    if os.access(file_in, os.R_OK):
        print ("File ", file_in ," is accessible to read")
    else:
        print ("File ", file_in ," is not accessible to read, exiting.")
        exit (1)
    reader = csv.reader(open(file_in,"r+"), delimiter=',')
    distance = list(reader)

    print(distance)

if __name__ == "__main__":
	  main()

#q1b.py - attempt 2
"""
UPGMA - Unweighted pair group method using arithmetic averages
Takes as input the distance matrix of species as a numpy array
Returns tree either as a dendrogram or in Newick format

Resources reffered to and used :

1. https://stackoverflow.com/questions/58532758/read-csv-file-into-list-and-convert-the-strings-into-integers-python 
2. http://etetoolkit.org/treeview/ 
3. https://www.geeksforgeeks.org/writing-data-from-a-python-list-to-csv-row-wise/ 
4. https://stackoverflow.com/questions/56025046/2d-list-to-csv-by-column 
5. https://en.wikipedia.org/wiki/UPGMA 
6. https://en.wikipedia.org/wiki/Phylogenetic_tree 
7. https://en.wikipedia.org/wiki/Child_node 
8. https://en.wikipedia.org/wiki/Tree_structure 
9. https://medium.com/@sharma.ravit/upgma-method-designing-a-phylogenetic-tree-9a708de18419#:~:text=%20UPGMA%20Method%3A%20Designing%20a%20Phylogenetic%20Tree%20,1%E2%80%932%20until%20the%20tree%20is%20complete%20More%20 
10. https://bit.ly/39T1tmb 
11. https://telliott99.blogspot.com/2010/11/upgma-in-python.html 
12. https://telliott99.blogspot.com/2010/11/upgma-in-python-2.html 
13. https://telliott99.blogspot.com/2010/11/upgma-in-python-3-sarich-data.html 
14. https://telliott99.blogspot.com/2010/03/clustering-with-upgma.html 
15. https://telliott99.blogspot.com/2010/04/visualizing-upgma-clustering.html 
16. https://www.geeksforgeeks.org/draw-a-tree-using-arcade-library-in-python/ 
17. https://www.geeksforgeeks.org/binarytree-module-in-python/ 
18. https://github.com/itsjinendrajain/Coding-Ninjas-Problem-Solving-Using-Python/tree/main/8.Searching%20%26%20Sorting 
19. https://www.geeksforgeeks.org/tree-sort/ 
20. http://www.bx.psu.edu/~dcking/man/newicktree.html#:~:text=The%20Newick%20Standard%20for%20representing%20trees%20in%20computer-readable,represented%20by%20the%20following%20sequence%20of%20printable%20characters%3A 
21. https://stackoverflow.com/questions/61117131/how-to-convert-a-binary-tree-to-a-newick-tree-using-python 
22. https://pure.mpg.de/rest/items/item_3258810_1/component/file_3273695/content 
23. http://etetoolkit.org/docs/2.3/tutorial/tutorial_trees.html 

"""

#%% import modules
import numpy as np
import itertools
import csv
import os
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
from Bio import pairwise2
import pandas as pd

def merge(list1, list2):
      
    merged_list = [(list1[i], list2[i]) for i in range(0, len(list1))]
    return merged_list

# Python program to get transpose
# elements of two dimension list
def transpose(l1, l2):
 
    # iterate over list l1 to the length of an item
    for i in range(len(l1[0])):
        # print(i)
        row =[]
        for item in l1:
            # appending to new list with values and index positions
            # i contains index position and item contains values
            row.append(item[i])
        l2.append(row)
    return l2

# class for nodes
class Node:
    """
    Data structure to store node of a UPGMA tree
    """

    def __init__(self, left=None, right=None, up_height=0.0, down_height=0.0):
        """
        Creating a node.
        For a single taxon, set taxon name as self.left, leave right as none.
        For an operational taxonomic unit(OTU) set left and right to child nodes.

        Parameters
        ----------
        left : default = none, taxon label
        right : default = none, taxon label
        up_height : float, default = 0.0, dist to parent node, if any
        down_height : float, default = 0.0, dist to child node, if any
        """
        self.left = left
        self.right = right
        self.uh = up_height
        self.dh = down_height

    def leaves(self) -> list:
        """
        Method to find the taxa under any given node, effectively equivalent to
        finding leaves of a binary tree. Only lists original taxa and not OTUs.

        Returns a list of node names, not nodes themselves.
        """
        if self == None:
            return []
        if self.right == None:
            return [self.left]
        leaves = self.left.leaves() + self.right.leaves()
        return leaves

    def __len__(self) -> int:
        """
        Method to define len() of a node.

        Returns the number of original taxa under any given node.
        """
        return sum(1 for taxa in self.leaves())

    def __repr__(self) -> str:
        """
        Method to give readable print output
        """
        return "-".join(self.leaves())


# class for UPGMA
class UPGMA:
    def __init__(self, dist_matrix: np.ndarray, taxa: list):
        """
        Initialize an UPGMA class.
        Takes a nxn distance matrix as input. A list of n taxon id is required
        in the same order as the distance matrix row/column

        Parameters
        ----------
        dist_matrix : numpy array, distance matrix of species
        taxa : list of int or str to identify taxa
        """
        self.distances = dist_matrix
        self.taxa = taxa
        self.build_tree(self.distances, self.taxa)

    def build_tree(self, dist_matrix: np.ndarray, taxa: list) -> Node:
        """
        Method to construct a tree from a given distance matrix and taxa list.

        Parameters
        ----------
        dist_matrix : np.ndarray of pairwise distances
        taxa : list of taxa id. Elements of lists have to be unique

        Returns the root node for constructed tree.
        """
        # creating node for each taxa
        nodes = list(Node(taxon) for taxon in taxa)

        # dictionary row/column id -> node
        rc_to_node = dict([i, j] for i, j in enumerate(nodes))
        
        # dictionary taxa -> row/column id
        taxa_to_rc = dict([i, j] for j, i in enumerate(taxa))
        
        # make copy of dist matrix to work on
        work_matrix = dist_matrix
        # set all diagonal elements to infinity for ease of finding least distance
        work_matrix = np.array(work_matrix, dtype=float)
        np.fill_diagonal(work_matrix, np.inf)

        # loop
        while len(nodes) > 1:
            # finding (row, col) of least dist
            least_id = np.unravel_index(work_matrix.argmin(), work_matrix.shape, "C")
            least_dist = work_matrix[least_id[0], least_id[1]]
            # nodes corresponding to (row, col)
            node1, node2 = rc_to_node[least_id[0]], rc_to_node[least_id[1]]
            
            # add OTU with node1 and node2 as children. set heights of nodes
            new_node = Node(node2, node1)
            nodes.append(new_node)
            node1.uh = least_dist / 2 - node1.dh
            node2.uh = least_dist / 2 - node2.dh
            new_node.dh = least_dist / 2
            nodes.remove(node1)
            nodes.remove(node2)
           
            # create new working distance matrix
            work_matrix = self.update_distance(dist_matrix, nodes, taxa_to_rc)
            
            # update row/col id -> node dictionary
            rc_to_node = dict([i, j] for i, j in enumerate(nodes))
        # set tree to root
        self.tree = nodes[0]

    def update_distance(
        self, dist_matrix: np.ndarray, nodes: list, taxa_to_rc: dict
    ) -> np.ndarray:
        """
        Method to make a new distance matrix with newer node list.

        Parameters
        ----------
        dist_matrix : np.ndarray of pairwise distances for all taxa
        nodes : list of updated nodes
        taxa_to_rc : dict for taxa -> row/col id

        Returns np.ndarray of pairwise distances for updated nodes
        """
        # dictionary for node -> row/col id
        node_to_rc = dict([i, j] for j, i in enumerate(nodes))
        
        rc = len(nodes)
        new_dist_matrix = np.zeros((rc, rc), dtype=float)
        for node1 in nodes:
            row = node_to_rc[node1]
            for node2 in nodes:
                node_pairs = list(itertools.product(node1.leaves(), node2.leaves()))
                col = node_to_rc[node2]
                new_dist_matrix[row, col] = sum(
                    dist_matrix[taxa_to_rc[i], taxa_to_rc[j]] for i, j in node_pairs
                ) / len(node_pairs)
        np.fill_diagonal(new_dist_matrix, np.inf)
        return new_dist_matrix


def tree_to_newick(t) -> str:
    """
    Function to convert tree to Newick, slightly modified form of the tree.py version.
    Takes the root node of an UPGMA tree as input
    """
    if t.right == None:
        return t.left + ":" + str(t.uh)
    else:
        return (
            "("
            + ",".join([tree_to_newick(x) for x in [t.left, t.right]])
            + "):"
            + str(t.uh)
        )


#main

def main ():
#to help resolve indent errors 
    file_in ='./Ndistance.txt'
    file_in_2='./Ntaxa.txt'
    file_out="./Nnewick.txt"
    if os.access(file_in, os.R_OK):
        print ("File ", file_in ," is accessible to read")
    else:
        print ("File ", file_in ," is not accessible to read, exiting.")
        exit (1)
    reader = csv.reader(open(file_in,"r+"), delimiter=',')
    distance = list(reader)
    print(distance)
    outer_out_list = []
    for inner_list in distance:
        innet_out_list = []
        for string in inner_list:
            innet_out_list.append(float (string))
        outer_out_list.append(innet_out_list)
    print(outer_out_list)
    
    if os.access(file_in_2, os.R_OK):
        print ("File ", file_in_2 ," is accessible to read\n")
    else:
        print ("File ", file_in_2 ," is not accessible to read, exiting.")
        exit (1)    
    reader_2 = csv.reader(open(file_in_2,"r+"), delimiter=',')
    taxa = list(reader_2)
    taxa = taxa[0]
    print( taxa )
    
    distances = np.array( outer_out_list )
    x = UPGMA(distances, taxa).tree
    final_output_newick=(tree_to_newick(x))
    print(final_output_newick)
    with open(file_out,"w") as f_out:
      f_out.write(final_output_newick)
    
if __name__ == "__main__":
    main()

"""# Now, we have completed question 1!!!

# Time for question 2 !! 
"""

#Create Protien.txt ,Pdistance.txt and BLOSUM62 to run q2a.py and q2b.py



#Copy paste whatever Protien.txt should contain, use FASTA format.
#Instead of running this code block you may also upload the files into the $PWD of google colab.

ProteinTextInput='''>NP_990553.1 insulin preproinsulin precursor [Gallus gallus]
MALWIRSLPLLALLVFSGPGTSYAAANQHLCGSHLVEALYLVCGERGFFYSPKARRDVEQPLVSSPLRGE
AGVLPFQQEEYEKVKRGIVEQCCHNTCSLYQLENYCN

>NP_001123565.1 insulin precursor [Canis lupus familiaris]
MALWMRLLPLLALLALWAPAPTRAFVNQHLCGSHLVEALYLVCGERGFFYTPKARREVEDLQVRDVELAG
APGEGGLQPLALEGALQKRGIVEQCCTSICSLYQLENYCN

>ATN38177.1 insulin [Labeo rohita]
MAVWLQAGALLFLLAVSSVNANAGAPQHLCGSHLVDALYLVCGPTGFFYNPKRDVDPLMGFLPPKSAQET
EVADFAFKDHAEVIRKRGIVEQCCHKPCSIFELQNYCN

>AAP35454.1 insulin [Homo sapiens]
MALWMRLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKTRREAEDLQVGQVELGG
GPGAGSLQPLALEGSLQKRGIVEQCCTSICSLYQLENYCN

>NP_062002.1 insulin-1 preproprotein [Rattus norvegicus]
MALWMRFLPLLALLVLWEPKPAQAFVKQHLCGPHLVEALYLVCGERGFFYTPKSRREVEDPQVPQLELGG
GPEAGDLQTLALEVARQKRGIVDQCCTSICSLYQLENYCN

>NP_001103242.1 insulin precursor [Sus scrofa]
MALWTRLLPLLALLALWAPAPAQAFVNQHLCGSHLVEALYLVCGERGFFYTPKARREAENPQAGAVELGG
GLGGLQALALEGPPQKRGIVEQCCTSICSLYQLENYCN

>NP_776351.2 insulin preproprotein [Bos taurus]
MALWTRLAPLLALLALWAPAPARAFVNQHLCGSHLVEALYLVCGERGFFYTPKARREVEGPQVGALELAG
GPGAGGLEGPPQKRGIVEQCCASVCSLYQLENYCN

>NP_001008996.1 insulin preproprotein [Pan troglodytes]
MALWMRLLPLLVLLALWGPDPASAFVNQHLCGSHLVEALYLVCGERGFFYTPKTRREAEDLQVGQVELGG
GPGAGSLQPLALEGSLQKRGIVEQCCTSICSLYQLENYCN

>AAA40590.1 insulin [Octodon degus]
MAPWMHLLTVLALLALWGPNSVQAYSSQHLCGSNLVEALYMTCGRSGFYRPHDRRELEDLQVEQAELGLE
AGGLQPSALEMILQKRGIVDQCCNNICTFNQLQNYCNVP

>AAA19033.1 insulin [Oryctolagus cuniculus]
MASLAALLPLLALLVLCRLDPAQAFVNQHLCGSHLVEALYLVCGERGFFYTPKSRREVEELQVGQAELGG
GPGAGGLQPSALELALQKRGIVEQCCTSICSLYQLENYCN

'''

#Copy paste whatever Blosum62.txt should contain, remove the header as its irrelevant.
#Instead of running this code block you may also upload the files into the $PWD of google colab.

Blosum62TextInput='''*  A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  Z  X  *
A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0 -2 -1  0 -4 
R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3 -1  0 -1 -4 
N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3  3  0 -1 -4 
D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3  4  1 -1 -4 
C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1 -3 -3 -2 -4 
Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2  0  3 -1 -4 
E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2  1  4 -1 -4 
G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3 -1 -2 -1 -4 
H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3  0  0 -1 -4 
I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3 -3 -3 -1 -4 
L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1 -4 -3 -1 -4 
K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2  0  1 -1 -4 
M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1 -3 -1 -1 -4 
F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1 -3 -3 -1 -4 
P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2 -2 -1 -2 -4 
S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2  0  0  0 -4 
T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0 -1 -1  0 -4 
W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3 -4 -3 -2 -4 
Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1 -3 -2 -1 -4 
V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4 -3 -2 -1 -4 
B -2 -1  3  4 -3  0  1 -1  0 -3 -4  0 -3 -3 -2  0 -1 -4 -3 -3  4  1 -1 -4 
Z -1  0  0  1 -3  3  4 -2  0 -3 -3  1 -1 -3 -1  0 -1 -3 -2 -2  1  4 -1 -4 
X  0 -1 -1 -1 -2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -2  0  0 -2 -1 -1 -1 -1 -1 -4 
* -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4  1'''



with open("Protein.txt", 'x') as f_out:
  f_out.write( ProteinTextInput )

with open("Pdistance.txt",'x') as f_out_2:
  f_out_2.write('')

with open("BLOSUM62.txt",'x') as f_out_3:
  f_out_3.write(Blosum62TextInput)


exit(0)

#q2a.py
'''
 After reading given input of Nucleotide.txt, I see that each new entry begins with a '>',
 followed by a line of Information on the gene, followed by some N lines of ATGC

 Identified as the FASTA format.

 I shall try to use biopython to give us the (n^2 - n)/2 values for distance matrix.

 Resources referred to 
 
 1. https://python.omics.wiki/biopython/examples/read-fasta
 2. https://www.geeksforgeeks.org/biopython-pairwise-alignment/
 3. https://stackoverflow.com/questions/20580657/how-to-read-a-fasta-file-in-python 
 4. https://vlab.amrita.edu/index.php?sub=3&brch=274&sim=1438&cnt=1 
 5. https://www.ebi.ac.uk/seqdb/confluence/display/JDSAT/Clustal+Omega+Help+and+Documentation#ClustalOmegaHelpandDocumentation-sequence 
 6. https://www.tutorialspoint.com/biopython/biopython_sequence_alignments.htm 
 7. https://www.geeksforgeeks.org/biopython-sequence-alignment/#:~:text=Biopython%20%E2%80%93%20Sequence%20Alignment%20Last%20Updated%20%3A%2011,identify%20the%20region%20of%20similarity%20among%20them.%20 
 8. https://www.ncbi.nlm.nih.gov/sra/docs/submitformats/#:~:text=fasta%20files%20may%20be%20submitted%20with%20corresponding%20qual%20files%2C%20too.%20these%20are%20recognized%20in%20the%20sra%20data%20processing%20pipeline%20as%20equivalent%20to%20fastq%20and%20should%20be%20specified%20as%20fastq%20when%20submitting%20the%20data%20files. 
 9. https://www.csestack.org/python-check-if-file-directory-exists/
 10. https://flexiple.com/python-create-file/ 
 11. https://www.askpython.com/python/built-in-methods/python-print-to-file#:~:text=Python%20%E2%80%93%20Print%20to%20File%201%20Method%201%3A,4%20Method%204%3A%20Use%20the%20logging%20module.%20 
 12. https://stackoverflow.com/questions/9426045/difference-between-exit0-and-exit1-in-python#:~:text=exit%20%281%29%20means%20there%20was%20some%20issue%20%2F,A%20zero%20error%20code%20means%20a%20successful%20exit. 


'''

import csv
import os
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
from Bio import pairwise2
import argparse
import pathlib
from Bio.PDB import FastMMCIFParser, MMCIFIO, PDBParser, PDBIO, Superimposer
from Bio.PDB.Polypeptide import is_aa
from Bio.Align import substitution_matrices
from Bio.Data.SCOPData import protein_letters_3to1 as aa3to1

def merge(list1, list2):
      
    merged_list = [(list1[i], list2[i]) for i in range(0, len(list1))]
    return merged_list

# Python program to get transpose
# elements of two dimension list
def transpose(l1, l2):
 
    # iterate over list l1 to the length of an item
    for i in range(len(l1[0])):
        # print(i)
        row =[]
        for item in l1:
            # appending to new list with values and index positions
            # i contains index position and item contains values
            row.append(item[i])
        l2.append(row)
    return l2

def main ():
#to help resolve indent errors 
    file_in ='./Protein.txt'
    file_in_2='./BLOSUM62.txt'
    file_out='./Pdistance.txt'

    if os.access(file_in, os.R_OK):
        print ("File ", file_in ," is accessible to read")
    else:
        print ("File ", file_in ," is not accessible to read, exiting.")
        exit (1)

    if os.access(file_in_2, os.R_OK):
        print ("File ", file_in_2 ," is accessible to read")
    else:
        print ("File ", file_in_2 ," is not accessible to read, exiting.")
        exit (1)
    
    if os.access(file_out, os.W_OK):
        print ("File ", file_out," is accessible to write \n")
    else:
        print ("File ", file_out," is not accessible to write, exiting.")
        exit (1)

    IdList = list ()
    ProtienSeqList= list ()

    with open(file_out, 'w') as f_out:
    #to help resolve indent errors   
        print("Beginning to Read ",file_in,"\n")
        for seq_record in SeqIO.parse(open(file_in, mode='r'), 'fasta'):
        #to help resolve indent errors 

            # remove .id from .description record (remove all before first space)
            seq_record.description=' '.join(seq_record.description.split()[1:])
            
            # do something (print or edit seq_record)       
            print('SequenceID = '  + seq_record.id)
            print('Description = ' + seq_record.description)
            print('Sequence = ' + seq_record.seq + '\n' )

            # Save the Sequence into ProtienSeqList and Id into IdList
            ProtienSeqList.append( seq_record.seq )
            IdList.append( seq_record.id )

        no_of_proteins = len(ProtienSeqList )
        print(no_of_proteins,'Proteins scanned into our List\n')
        print("Our Lists are : ",merge ( IdList, ProtienSeqList ))
        print(ProtienSeqList)
        print(IdList,"\n")

        #Initialize distance matrix
        dist_Matrix=list()

        #Now to find distances, pairwise 
        for i in range(0,no_of_proteins,1):
            column= list ()
            for i_1 in range(0,i+1,1):
                column.append(0)
            for j in range (i+1, no_of_proteins, 1):
                #compare with j'th protein, and find best pairing.
                # alignments = pairwise2.align.globalxx(ProtienSeqList[i], ProtienSeqList[j])
                test_alignments =  pairwise2.align.globalds( ProtienSeqList[i], ProtienSeqList[j] , substitution_matrices.load("BLOSUM62"), one_alignment_only=True, open=-10.0, extend=-0.5, penalize_end_gaps=(False, False))
                length = ( max(len(ProtienSeqList[i]), len(ProtienSeqList[j])) // 1)
                score= 0
                for alignment in test_alignments: 
                    # print( (alignment[2]//1) , (alignment[4]//1) , ( (alignment[2]//1)/ (alignment[4]//1) ) ) 
                    if ( (alignment[2]//1) >  score ):
                        score = (alignment[2]//1)
                norm_score = score/length
                print(score,length,norm_score)
                #add to 'column'
                column.append(norm_score)
            dist_Matrix.append(column)
        out_Matrix=list ()
        out_Matrix = transpose (dist_Matrix, out_Matrix)
        print(out_Matrix)
        writer = csv.writer(f_out)
        # f_out.write(str (no_of_nucleotides)+",\n")
        writer.writerows(out_Matrix)
    file_out_2="./Ptaxa.txt"
    with open(file_out_2, 'w') as f_out_2:
      writer = csv.writer(f_out_2)
      writer.writerow (IdList)

if __name__ == "__main__":
    main()

#q2b.py - Basically a Copy-Paste of q1b.py
"""
UPGMA - Unweighted pair group method using arithmetic averages
Takes as input the distance matrix of species as a numpy array
Returns tree either as a dendrogram or in Newick format

Resources reffered to and used :

1. https://stackoverflow.com/questions/58532758/read-csv-file-into-list-and-convert-the-strings-into-integers-python 
2. http://etetoolkit.org/treeview/ 
3. https://www.geeksforgeeks.org/writing-data-from-a-python-list-to-csv-row-wise/ 
4. https://stackoverflow.com/questions/56025046/2d-list-to-csv-by-column 
5. https://en.wikipedia.org/wiki/UPGMA 
6. https://en.wikipedia.org/wiki/Phylogenetic_tree 
7. https://en.wikipedia.org/wiki/Child_node 
8. https://en.wikipedia.org/wiki/Tree_structure 
9. https://medium.com/@sharma.ravit/upgma-method-designing-a-phylogenetic-tree-9a708de18419#:~:text=%20UPGMA%20Method%3A%20Designing%20a%20Phylogenetic%20Tree%20,1%E2%80%932%20until%20the%20tree%20is%20complete%20More%20 
10. https://bit.ly/39T1tmb 
11. https://telliott99.blogspot.com/2010/11/upgma-in-python.html 
12. https://telliott99.blogspot.com/2010/11/upgma-in-python-2.html 
13. https://telliott99.blogspot.com/2010/11/upgma-in-python-3-sarich-data.html 
14. https://telliott99.blogspot.com/2010/03/clustering-with-upgma.html 
15. https://telliott99.blogspot.com/2010/04/visualizing-upgma-clustering.html 
16. https://www.geeksforgeeks.org/draw-a-tree-using-arcade-library-in-python/ 
17. https://www.geeksforgeeks.org/binarytree-module-in-python/ 
18. https://github.com/itsjinendrajain/Coding-Ninjas-Problem-Solving-Using-Python/tree/main/8.Searching%20%26%20Sorting 
19. https://www.geeksforgeeks.org/tree-sort/ 
20. http://www.bx.psu.edu/~dcking/man/newicktree.html#:~:text=The%20Newick%20Standard%20for%20representing%20trees%20in%20computer-readable,represented%20by%20the%20following%20sequence%20of%20printable%20characters%3A 
21. https://stackoverflow.com/questions/61117131/how-to-convert-a-binary-tree-to-a-newick-tree-using-python 
22. https://pure.mpg.de/rest/items/item_3258810_1/component/file_3273695/content 
23. http://etetoolkit.org/docs/2.3/tutorial/tutorial_trees.html 

"""

#%% import modules
import numpy as np
import itertools
import csv
import os
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
from Bio import pairwise2
import pandas as pd

def merge(list1, list2):
      
    merged_list = [(list1[i], list2[i]) for i in range(0, len(list1))]
    return merged_list

# Python program to get transpose
# elements of two dimension list
def transpose(l1, l2):
 
    # iterate over list l1 to the length of an item
    for i in range(len(l1[0])):
        # print(i)
        row =[]
        for item in l1:
            # appending to new list with values and index positions
            # i contains index position and item contains values
            row.append(item[i])
        l2.append(row)
    return l2

# class for nodes
class Node:
    """
    Data structure to store node of a UPGMA tree
    """

    def __init__(self, left=None, right=None, up_height=0.0, down_height=0.0):
        """
        Creating a node.
        For a single taxon, set taxon name as self.left, leave right as none.
        For an operational taxonomic unit(OTU) set left and right to child nodes.

        Parameters
        ----------
        left : default = none, taxon label
        right : default = none, taxon label
        up_height : float, default = 0.0, dist to parent node, if any
        down_height : float, default = 0.0, dist to child node, if any
        """
        self.left = left
        self.right = right
        self.uh = up_height
        self.dh = down_height

    def leaves(self) -> list:
        """
        Method to find the taxa under any given node, effectively equivalent to
        finding leaves of a binary tree. Only lists original taxa and not OTUs.

        Returns a list of node names, not nodes themselves.
        """
        if self == None:
            return []
        if self.right == None:
            return [self.left]
        leaves = self.left.leaves() + self.right.leaves()
        return leaves

    def __len__(self) -> int:
        """
        Method to define len() of a node.

        Returns the number of original taxa under any given node.
        """
        return sum(1 for taxa in self.leaves())

    def __repr__(self) -> str:
        """
        Method to give readable print output
        """
        return "-".join(self.leaves())


# class for UPGMA
class UPGMA:
    def __init__(self, dist_matrix: np.ndarray, taxa: list):
        """
        Initialize an UPGMA class.
        Takes a nxn distance matrix as input. A list of n taxon id is required
        in the same order as the distance matrix row/column

        Parameters
        ----------
        dist_matrix : numpy array, distance matrix of species
        taxa : list of int or str to identify taxa
        """
        self.distances = dist_matrix
        self.taxa = taxa
        self.build_tree(self.distances, self.taxa)

    def build_tree(self, dist_matrix: np.ndarray, taxa: list) -> Node:
        """
        Method to construct a tree from a given distance matrix and taxa list.

        Parameters
        ----------
        dist_matrix : np.ndarray of pairwise distances
        taxa : list of taxa id. Elements of lists have to be unique

        Returns the root node for constructed tree.
        """
        # creating node for each taxa
        nodes = list(Node(taxon) for taxon in taxa)

        # dictionary row/column id -> node
        rc_to_node = dict([i, j] for i, j in enumerate(nodes))
        
        # dictionary taxa -> row/column id
        taxa_to_rc = dict([i, j] for j, i in enumerate(taxa))
        
        # make copy of dist matrix to work on
        work_matrix = dist_matrix
        # set all diagonal elements to infinity for ease of finding least distance
        work_matrix = np.array(work_matrix, dtype=float)
        np.fill_diagonal(work_matrix, np.inf)

        # loop
        while len(nodes) > 1:
            # finding (row, col) of least dist
            least_id = np.unravel_index(work_matrix.argmin(), work_matrix.shape, "C")
            least_dist = work_matrix[least_id[0], least_id[1]]
            # nodes corresponding to (row, col)
            node1, node2 = rc_to_node[least_id[0]], rc_to_node[least_id[1]]
            
            # add OTU with node1 and node2 as children. set heights of nodes
            new_node = Node(node2, node1)
            nodes.append(new_node)
            node1.uh = least_dist / 2 - node1.dh
            node2.uh = least_dist / 2 - node2.dh
            new_node.dh = least_dist / 2
            nodes.remove(node1)
            nodes.remove(node2)
           
            # create new working distance matrix
            work_matrix = self.update_distance(dist_matrix, nodes, taxa_to_rc)
            
            # update row/col id -> node dictionary
            rc_to_node = dict([i, j] for i, j in enumerate(nodes))
        # set tree to root
        self.tree = nodes[0]

    def update_distance(
        self, dist_matrix: np.ndarray, nodes: list, taxa_to_rc: dict
    ) -> np.ndarray:
        """
        Method to make a new distance matrix with newer node list.

        Parameters
        ----------
        dist_matrix : np.ndarray of pairwise distances for all taxa
        nodes : list of updated nodes
        taxa_to_rc : dict for taxa -> row/col id

        Returns np.ndarray of pairwise distances for updated nodes
        """
        # dictionary for node -> row/col id
        node_to_rc = dict([i, j] for j, i in enumerate(nodes))
        
        rc = len(nodes)
        new_dist_matrix = np.zeros((rc, rc), dtype=float)
        for node1 in nodes:
            row = node_to_rc[node1]
            for node2 in nodes:
                node_pairs = list(itertools.product(node1.leaves(), node2.leaves()))
                col = node_to_rc[node2]
                new_dist_matrix[row, col] = sum(
                    dist_matrix[taxa_to_rc[i], taxa_to_rc[j]] for i, j in node_pairs
                ) / len(node_pairs)
        np.fill_diagonal(new_dist_matrix, np.inf)
        return new_dist_matrix


def tree_to_newick(t) -> str:
    """
    Function to convert tree to Newick, slightly modified form of the tree.py version.
    Takes the root node of an UPGMA tree as input
    """
    if t.right == None:
        return t.left + ":" + str(t.uh)
    else:
        return (
            "("
            + ",".join([tree_to_newick(x) for x in [t.left, t.right]])
            + "):"
            + str(t.uh)
        )


#main

def main ():
#to help resolve indent errors 
    file_in ='./Pdistance.txt'
    file_in_2='./Ptaxa.txt'
    file_out="./Pnewick.txt"
    if os.access(file_in, os.R_OK):
        print ("File ", file_in ," is accessible to read")
    else:
        print ("File ", file_in ," is not accessible to read, exiting.")
        exit (1)
    reader = csv.reader(open(file_in,"r+"), delimiter=',')
    distance = list(reader)
    print(distance)
    outer_out_list = []
    for inner_list in distance:
        innet_out_list = []
        for string in inner_list:
            innet_out_list.append(float (string))
        outer_out_list.append(innet_out_list)
    print(outer_out_list)
    
    if os.access(file_in_2, os.R_OK):
        print ("File ", file_in_2 ," is accessible to read\n")
    else:
        print ("File ", file_in_2 ," is not accessible to read, exiting.")
        exit (1)    
    reader_2 = csv.reader(open(file_in_2,"r+"), delimiter=',')
    taxa = list(reader_2)
    taxa = taxa[0]
    print( taxa )
    
    distances = np.array( outer_out_list )
    x = UPGMA(distances, taxa).tree
    final_output_newick=(tree_to_newick(x))
    print(final_output_newick)
    with open(file_out,"w") as f_out:
      f_out.write(final_output_newick)
    
if __name__ == "__main__":
    main()

"""And we are Done!!! """